\documentclass[
	a4paper,
	landscape
	article
]{article}
\usepackage[
	a4paper,
	landscape,
	twocolumn,
	left=0.8cm,
	right=0.3cm,
% Weird top and bottom margins because of fancyhdr package
	top=1.5cm,
	bottom=-0.3cm,
	columnsep=1cm
]{geometry}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[compact]{titlesec}		% shrink section whitespace
\usepackage{ifthen}
\usepackage{nicefrac}
\usepackage{hyperref}

%*************** Layout ***************
\setlength{\columnseprule}{0.2pt}
\newcommand{\latexcolumnseprulecolor}{\color{red}}
\titlespacing{\section}{0pt}{0pt}{0pt}
\sloppy

% A red divider in the middle of the page
\usepackage{etoolbox}
\makeatletter
\patchcmd\@outputdblcol{% find
	\normalcolor\vrule
}{% and replace by
	\latexcolumnseprulecolor\vrule
}{% success
}{% failure
	\@latex@warning{Patching \string\@outputdblcol\space failed}%
}
\makeatother


%*************** Title ***************

% all the \vspace are for reducing the vertical spacing
\title{
	\vspace{-4em}
	\includegraphics[scale=0.7]{./logo.eps}\\
	\vspace{-1.5em}
	Team Code Reference
	\vspace{-0.7em}
}
%\author{ Timon Knigge, Ragnar Groot Koerkamp, \& Harry Smit }
\author{
	\Large \textbf{Curiously Recurring}\\
%	Timon Knigge, Ragnar Groot Koerkamp, \& Harry Smit
}
\date{
	\vspace{-0.5em}
	Utrechts Kampioenschap Programmeren - BAPC Preliminaries\\
	19 september 2015
	\vspace{-1em}
}


%*************** Table of Contents ***************
\usepackage[toc]{multitoc}			% multicolumn toc
\usepackage{tocloft}				% to reduce toc spacing
\renewcommand*{\multicolumntoc}{2}
% reduce section spacing in toc
\setlength{\cftbeforesecskip}{0pt}
% remove the toc title
\makeatletter
\renewcommand{\@cftmaketoctitle}{}
\makeatother


%*************** Headings ***************
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\setlength{\headsep}{0.4em}
\setlength{\footskip}{0em}
\lhead{{\bfseries Curiously Recurring} Utrecht University}
\rhead{\thepage}
\chead{\leftmark}

%*************** Code highlighting ***************
\lstset{
	backgroundcolor=\color{white},
	tabsize=4,
	language=C++,
	basicstyle=\footnotesize\ttfamily,
	frame=lines,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
	keywordstyle=\color[rgb]{0, 0, 1},
	commentstyle=\color[rgb]{0, 0.5, 0},
	stringstyle=\color{red}
}


%*************** Section entries ***************
% \entry{name}{description}{snippet location}{complexity}{dependencies}
\newcommand{\entry}[5]{
	\subsection{#1}
	#2
	\ifthenelse{\equal{#4}{}}{}{\noindent\textbf{Complexity:} #4}
	\ifthenelse{\equal{#5}{}}{}{\noindent\textbf{Dependencies:} #5}
	\ifthenelse{\equal{#3}{}}{}{\lstinputlisting[firstline=2]{#3}}
}
\newcommand{\otherentry}[3]{
	\subsection{#1}
	#2
	\lstinputlisting[language=]{#3}
}


%*************** Begin document ***************
\begin{document}


%*************** Reduce align spacing ***************
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{0pt}
\setlength{\abovedisplayshortskip}{0pt}
\setlength{\belowdisplayshortskip}{0pt}

%*************** Titlepage ***************
{\let\newpage\relax\maketitle}
\tableofcontents
\thispagestyle{empty}
\newpage

%*************** Contents ***************

\section{Templates}
% Can't use the \entry command, because filetype is tex
\otherentry{Vimrc}{}
{./snippets/vimrc_tcr}

\entry{C++ Template}{}
{./snippets/header_tcr.h}{}{}

\entry{Java Template}{}
{./snippets/template.java}{}{}

\section{Data Structures}

\entry{Union Find}{}
{./snippets/datastructures/unionfind.cpp}{}{}

\entry{Max Queue}
{\texttt{dequeue} runs in amortized constant time. Can be modified to query minimum, gcd/lcm, set union/intersection (use bitmasks), etc.}
{./snippets/datastructures/maxqueue.cpp}{}{}

\entry{Fenwick Tree}
{The tree is 1-based! Use indices $1..n$.}
{./snippets/datastructures/fenwick.cpp}{}{}

\entry{2D Fenwick Tree}
{Can easily be extended to any dimension.}
{./snippets/datastructures/fenwick2d.cpp}{}{}

\entry{Segment Tree}
{The range should be of the form $2^p$.}
{./snippets/datastructures/segmenttree.cpp}{}{}

\entry{Lazy Dynamic Segment Tree}
{}
{./snippets/datastructures/segmenttree_dynamic.cpp}{}{}

\entry{Implicit Cartesian Tree}
{The indices are zero-based. Also, don't forget to initialise the empty tree to \texttt{NULL}. (Pretty much) all operations take $O(\log n)$ time.}
{./snippets/datastructures/implicit-cartesian-tree.cpp}{}{}

\entry{AVL Tree}
{Can be augmented to support in $O(\log n)$ time: range queries/updates (similar to a segment tree), insert at position $n$/query for position $n$, order statistics, etc.}
{./snippets/datastructures/avl.cpp}{}{}

\entry{Treap}
{Can be used like the built-in \texttt{set}, except that it also supports order statistics, can be merged/split in $O(\log n)$ time, can support range queries, and more.}
{./snippets/datastructures/treap.cpp}{}{}

\entry{Prefix Trie}{}
{./snippets/datastructures/trie.cpp}{}{}

\entry{Suffix Array}{Note: dont forget to invert the returned array.}
{./snippets/datastructures/suffixarray.cpp}{$O(n \log^2 n)$}{}

\entry{Built-in datastructures}{}
{./snippets/datastructures/builtin.cpp}{}{}

\section{Basic Graph algorithms}

\entry{Edge Classification}{}
{./snippets/graphs/edgeclassification.cpp}
{$O(V + E)$}{}

\entry{Topological sort}{}
{./snippets/graphs/toposort.cpp}
{$O(V + E)$}{}

\entry{Tarjan: SCCs}
{}
{./snippets/graphs/tarjan.cpp}
{$O(V + E)$}
{}

\entry{Biconnected components}
{}
{./snippets/graphs/biconnected_component.cpp}
{$O(V + E)$}
{}

\entry{Kruskal's algorithm}{}
{./snippets/graphs/kruskal.cpp}
{$O(E \log V)$}
{Union Find}

\entry{Prim's algorithm}{}
{./snippets/graphs/prim.cpp}
{$O(E \log V)$}{}

\entry{Dijkstra's algorithm}{}
{./snippets/graphs/dijkstra.cpp}
{$O((V + E) \log V)$}{}

%\entry{Bellmann-Ford algorithm}
%{Returns \texttt{true} if the graph has no negative cycles.}
%{./snippets/graphs/bellmannford.cpp}
%{$O(VE)$}{}

\entry{Bellmann-Ford}
{An improved (but slower) version of Bellmann-Ford that can indicate for each vertex separately whether it is reachable, and if so, whether there is a lowerbound on the length of the shortest path.}
{./snippets/graphs/bellmannford-extended.cpp}
{$O(VE)$}{}

\entry{Floyd-Warshall algorithm}
{Transitive closure: \texttt{R[a,c] = R[a,c] | (R[a,b] \& R[b,c]))}, transitive reduction: \texttt{R[a,c] = R[a,c] \& !(R[a,b] \& R[b, c]).}}
{./snippets/graphs/floydwarshall.cpp}
{$O(V^3)$}{}

\entry{Hierholzer's algorithm}
{Verify existence of the circuit/trail in advance (see Theorems in Graph Theory for more information). When looking for a trail, be sure to specify the starting vertex.}
{./snippets/graphs/euleriancircuits.cpp}
{$O(V + E)$}{}

\entry{Bron-Kerbosch}
{Count the number of maximal cliques in a graph with up to a few hundred nodes.}
{./snippets/graphs/bronkerbosch.cpp}
{$O(3^{\nicefrac n3})$}{}


\subsection{Theorems in Graph Theory}
\begin{description}
	\item[Dilworth's theorem]:
		The minimum number of disjoint chains into which S can be decomposed equals the length of a longest antichain of S.

		Compute by defining a bipartite graph with a source $u_x$ and sink $v_x$ for each vertex $x$, and adding an edge $(u_x, v_y)$ if $x \leq y, x \neq y$. Let $m$ denote the size of the maximum matching, then the number of disjoint chains is $|S| - m$ (the collection of unmatched endpoints).

	\item[Mirsky's theorem]:
		The minimum number of disjoint antichains into which S can be decomposed equals the length of a longest chain of S.

		Compute by defining $L_v$ to be the length of the longest chain ending at $v$. Sort $S$ topologically and use bottom-up DP to compute $L_u$ for all $u \in S$.

	\item[Kirchhoff's theorem]:
		Define a $V \times V$ matrix $M$ as: $M_{ij} = deg(i)$ if $i == j$, $M_{ij} = - 1$ if $\{i, j\} \in E$, $M_{ij} = 0$ otherwise. Then the number of distinct spanning trees equals any minor of $M$.

	\item[Acyclicity]:
		A directed graph is acyclic if and only if a depth-first search yields no back edges.

	\item[Euler Circuits and Trails]:
		In an \textit{undirected graph}, an \textit{Eulerian Circuit} exists if and only if all vertices have even degree, and all vertices of nonzero degree belong to a single connected component. In an \textit{undirected graph}, an \textit{Eulerian Trail} exists if and only if at most two vertices have odd degree, and all of its vertices of nonzero degree belong to a single connected component. In a \textit{directed graph}, an \textit{Eulerian Circuit} exists if and only if every vertex has equal indegree and outdegree, and all vertices of nonzero degree belong to a single strongly connected component. In a \textit{directed graph}, an \textit{Eulerian Trail} exists if and only at most one vertex has $outdegree - indegree = 1$, at most one vertex has $indegree - outdegree = 1$, every other vertex has equal indegree and outdegree, and all vertices of nonzero degree belong to a single strongly connected component \textit{in the underlying undirected graph}.
\end{description}

\entry{Centroid Decomposition}
{In case it is necessary to work with the subtrees directly, consider timestamping each node during the decomposition}
{./snippets/graphs/centroid.cpp}
{$O(n \log n)$}{}

\entry{Heavy-Light decomposition}
{}
{./snippets/graphs/heavylight.cpp}
{$O(n)$}{}

\section{Flow and Matching}

%\entry{Flow Network}
%{Generic flow network used by the algorithms in this section. Should not require any modifications. \emph{Note:} Get the reverse of \texttt{e[i]} as \texttt{e[i \textasciicircum  1]}. Don't forget to \texttt{cleanup()} afterwards.}
%{./snippets/flowalgorithms/flownetwork.cpp}{}{}


\entry{Flow Graph}
{Structure used by the following flow algorithms.}
{./snippets/flowalgorithms/flowgraph.cpp}{}{}

%\entry{Edmonds-Karp algorithm}{}
%{./snippets/flowalgorithms/edmondskarp.cpp}
%{$O(VE^2)$}
%{Flow Network}

%\entry{Dinic's algorithm}{}
%{./snippets/flowalgorithms/dinic.cpp}
%{$O(V^2E)$}
%{Flow Network}

\entry{Dinic}{}
{./snippets/flowalgorithms/dinic_ragnar.cpp}
{$O(V^2E)$}
{Flow Graph}

\entry{Minimum Cut Inference}
{The maximum flow equals the minimum cut. Only use this if the specific edges are needed. Run a flow algorithm in advance.}
{./snippets/flowalgorithms/infermincut.cpp}
{$O(V + E)$}
{Flow Network}

%\entry{Edmonds Karp Ragnar}{}
%{./snippets/flowalgorithms/edmondskarp_ragnar.cpp}
%{$O(VE^2)$}
%{Flow Graph}

\entry{Min cost flow}{}
{./snippets/flowalgorithms/mincostflow.cpp}
{}
{Flow Graph}


%\entry{Push Relabel Ragnar}{}
%{./snippets/flowalgorithms/push_relabel.cpp}
%{}
%{Flow Graph}

%\entry{Hopcroft Karp Ragnar}{}
%{./snippets/flowalgorithms/hopcroft_karp_ragnar.cpp}
%{}
%{Flow Graph}

\subsection{Min edge capacities}
Make a supersource $S$ and supersink $T$.
When there are a lowerbound $l(u,v)$ and upperbound $c(u,v)$,
add edge with capacity $c-l$.
Furthermore, add $(t,s)$ with capacity $\infty$.
\begin{align*}
	M(u) = \sum_v l(v,u) - \sum_v l(u,v)
\end{align*}
If $M(u)>0$, add $(S,u)$ with capacity $M(u)$. Otherwise add $(u,T)$ with capacity $-M(u)$.
Run Dinic to find a max flow. This is a feasible flow in the original graph if all edges from $S$ are saturated.
Run Dinic again in the residual graph of the original problem to find the maximal feasible flow.

\subsection{Min vertex capacities}
$x(u)$ is the amount of flow that is extracted at $u$, or inserted when $x(u)<0$.
If $\sum_u s(u) > 0$, add edge $(t,\tilde t)$ with capacity $\infty$,
and set $x(\tilde t)=-\sum_ux(u)$. Otherwise add $(\tilde s,s)$ and set $x(\tilde s)=-\sum_u x(u)$.
$\tilde s$ or $\tilde t$ is the new source/sink.
Now, add $S$ and $T$, $(t,s)$ with capacity $\infty$.
If $x(u)>0$, add $(S,u)$ with capacity $x(u)$. Otherwise add $(u,T)$ with capacity $x(u)$.
Use Dinic to find a max flow. If all edges from $S$ are saturated, this is a feasible flow.
Run Dinic again in the residual graph to find the maximal feasible flow.



\section{Combinatorics \& Probability}

\entry{Stable Marriage Problem}
{If $m = w$, the algorithm finds a complete, optimal matching. \texttt{mpref[i][j]} gives the id of the j'th preference of the i'th man. \texttt{wpref[i][j]} gives the preference the j'th woman assigns to the i'th man. Both \texttt{mpref} and \texttt{wpref} should be zero-based permutations.}
{./snippets/combinatorics/stablemarriage.cpp}
{$O(mw)$}{}

%\entry{Meet in the Middle}
%{Sufficient for $2 \leq n \leq 14$.}
%{./snippets/combinatorics/meetinthemiddle.cpp}
%{$O(n^2\binom{n}
%{n/2}\big(\frac{n}
%{2}\big)!)$}{}

\entry{KP procedure}
{Solves a two variable single constraint integer linear programming problem. It can be extended to an arbitrary number of constraints by inductively decomposing the constrained region into its binding constraints (hence the $L$ and $U$), and solving for each region.}
{./snippets/combinatorics/twovariablesilp.cpp}
{$O(d^2 log(d)log(log(d)))$}{}

\entry{2-SAT}{}
{./snippets/combinatorics/2-sat.cpp}
{$O(|\text{variables}|+|\text{implications}|)$}
{Tarjan's}

\section{Geometry}

%\entry{Essentials}{}
%{./snippets/geometry/geometryessentials.cpp}{}{}
%
%\entry{Essentials, Ragnar}{}
%{./snippets/geometry/basics_ragnar.cpp}{}
%{}

\entry{Essentials}{}
{./snippets/geometry/essentials.cpp}{}
{}

\entry{Convex Hull}{}
{./snippets/geometry/convexhull.cpp}
{$O(n \log n)$}
{Geometry Essentials}

%\entry{Polygon}{}
%{./snippets/geometry/polygon.cpp}{}
%{Geometry Essentials}


\subsection{Formulae}

\begin{align*}
	[ABC]
	&= rs
	= \frac 12 ab\sin\gamma
	= \frac{abc}{4R}
	= \sqrt{s(s-a)(s-b)(s-c)}
	= \frac 12\left| (B-A, C-A)^T \right|
\end{align*}
\begin{align*}
	s &= \frac {a+b+c}2 & 2R &=\frac{a}{\sin \alpha}\\
	\textrm{cosine rule:}&&  c^2 &= a^2 + b^2 - 2ab\cos \gamma\\
	\textrm{Euler:}&&  1 + CC &= V - E + F\\
	\textrm{Pick:}&& Area &= interior + \frac{boundary}2 - 1
\end{align*}

Given a non-self-intersecting closed polygon on $n$ vertices, given as $(x_i, y_i)$, its centroid $(C_x, C_y)$ is given as:

\begin{align*}
	C_x = \frac{1}{6A} \sum_{i = 0}^{n - 1} (x_i + x_{i+1}) (x_i y_{i+1} - x_{i+1} y_i)
\end{align*}
\begin{align*}
	C_y = \frac{1}{6A} \sum_{i = 0}^{n - 1} (y_i + y_{i+1}) (x_i y_{i+1} - x_{i+1} y_i)
\end{align*}
\begin{align*}
	A = \frac{1}{2} \sum_{i = 0}^{n - 1} (x_i y_{i+1} - x_{i+1} y_i)
\end{align*}

\section{Mathematics}

\entry{Primes}{
	\begin{align*}
		10^3 + \{-9,-3,9,13\},
		\quad 10^6 + \{-17, 3, 33\},
		\quad 10^9 + \{7,9,21,33,87\}
	\end{align*}
}
{./snippets/mathematics/primes.cpp}{}{}

\entry{Number theoretic algorithms}{}
{./snippets/mathematics/numbertheory.cpp}{}{}

\entry{Lucas' theorem}{}
{./snippets/mathematics/lucas.cpp}{}{}

\entry{Complex Numbers}
{Faster-than-built-in complex numbers}
{./snippets/mathematics/complex.cpp}{}{}

\entry{Fast Fourier Transform}
{Calculates the discrete convolution of two vectors. Note that the method accepts and outputs complex numbers, and the input is changed in place.}
{./snippets/mathematics/fft.cpp}
{$O(n \log n)$}
{Bitmasking, Complex Numbers}

\entry{Matrix equation solver}
{Solve $MX=A$ for $X$, and write the square matrix $M$ in reduced row echelon form, where each row starts with a $1$, and this $1$ is the only nonzero value in its column.}
{./snippets/matrix/solve.cpp}{}{}

\entry{Matrix Exponentation}
{Matrix exponentation in logarithmic time.}
{./snippets/matrix/matrixexponentation.cpp}{}{}

\entry{Simplex algorithm}
{
	Maximize $c^tx$ subject to $Ax \leq b$ and $x\geq 0$.
	$A[m \times n]$, $b[m]$, $c[n]$, $x[n]$. Solution in $x$.
}
{./snippets/matrix/simplex.cpp}{}{}

\section{Strings}

\entry{Knuth Morris Pratt}{}
{./snippets/strings/knuthmorrispratt.cpp}
{$O(n + m)$}{}

\entry{Z-algorithm}
{To match pattern $P$ on string $S$: pick $\Phi$ s.t. $\Phi \notin P$, find $Z$ of $P{\Phi}S$.}
{./snippets/strings/zalgorithm.cpp}
{$O(n)$}{}

\entry{Aho-Corasick}
{Constructs a Finite State Automaton that can match $k$ patterns of total length $m$ on a string of size $n$.}
{./snippets/strings/ahocorasick.cpp}
{$O(n + m + k)$}{}

\entry{Manacher's Algorithm}
{Finds the largest palindrome centered at each position.}
{./snippets/strings/manacher.cpp}
{$O(|S|)$}{}

\section{Miscellaneous}

\entry{LIS}
{Finds the longest strictly increasing subsequence. To find the longest non-decreasing subsequence, insert pairs $(a_i, i)$. Note that the elements should be totally ordered. To find the LIS of a sequence of elements from a partially ordered set (e.g. coordinates in the plane), replace \texttt{lis[]} with a set of equivalent elements, at a cost of another $O(\log n)$ factor.}
{./snippets/misc/lis.cpp}
{$O(n \log n)$}{}

\entry{Randomisation}{Might be useful for NP-Complete/Backtracking problems}
{./snippets/misc/randomisation.cpp}{}{}

\section{Helpers}

\entry{Golden Section Search}
{For a discrete search: use binary search on the difference of successive elements, see the section on Binary Search.}
{./snippets/helpers/goldensectionsearch.cpp}
{$O(\log {1 / \epsilon})$}{}

\entry{Binary Search}{}
{./snippets/helpers/binarysearch.cpp}
{$O(\log n), O(\log {1 / \epsilon})$}{}

\entry{Bitmasking}{}
{./snippets/helpers/bitmasking.cpp}{}{}

%\entry{QuickSelect}
%{Running time is expected, quadratic in the worst case. Alternatingly breaks ties left and right, so it should be pretty resilient to edge cases. Note that the vector is changed in the process. Recursion depth is $O(\log n)$.}
%{./snippets/helpers/quickselect.cpp}
%{$O(n)$}{}

\entry{Fast IO}{}{./snippets/helpers/fastinput.cpp}{}{}

\newpage
\section{Strategies}
\subsection{Techniques}
\begin{itemize}
\setlength\itemsep{0em}
	\item Bruteforce: meet-in-the-middle, backtracking, memoization
	\item DP (write full draft, include ALL loop bounds), easy direction
	\item Precomputation
	\item Divide and Conquer
	\item Binary search
	\item $lg(n)$ datastructures
	\item Mathematical insight
	\item Randomisation
	\item Look at it backwards
	\item Common subproblems? Memoization
	\item Compute modulo primes and use CRT
\end{itemize}

\subsection{WA}
\begin{itemize}
\setlength\itemsep{0em}
	\item Read carefully
	\item Check bounds (use long long or long double)
	\item EDGE CASES: $n\in\{-1,0,1,2\}$. Empty list/graph?
	\item Not enough precision
	\item Assertions
	\item Missing modulo operators
\end{itemize}

\subsection{TLE}
\begin{itemize}
\setlength\itemsep{0em}
	\item Infinite loop
	\item Use scanf or fastIO instead of cin
	\item Wrong algorithm
\end{itemize}

\end{document}
