\documentclass[
	a4paper,
	landscape,
	%twoside,
	10pt,
	article
]{article}
\usepackage[
	a4paper,
	landscape,
	twocolumn,
	left=0.8cm,
	right=0.3cm,
% Weird top and bottom margins because of fancyhdr package
	top=1.8cm,
	bottom=-0.3cm,
	columnsep=1cm,
% Set margins on even and odd pages equal
	hmarginratio=1:1,
	asymmetric
]{geometry}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[compact]{titlesec}		% shrink section whitespace
\usepackage{ifthen}
\usepackage{nicefrac}
\usepackage{hyperref}

%*************** Layout ***************
\setlength{\columnseprule}{0.2pt}
\newcommand{\latexcolumnseprulecolor}{\color{red}}
\titlespacing{\section}{0pt}{0pt}{0pt}
\sloppy

% A red divider in the middle of the page
\usepackage{etoolbox}
\makeatletter
\patchcmd\@outputdblcol{% find
	\normalcolor\vrule
}{% and replace by
	\latexcolumnseprulecolor\vrule
}{% success
}{% failure
	\@latex@warning{Patching \string\@outputdblcol\space failed}%
}
\makeatother


%*************** Title ***************

% all the \vspace are for reducing the vertical spacing
\title{
	\vspace{-5em}
	\includegraphics[scale=0.7]{./logo.eps}\\
	\vspace{-1.5em}
	Team Code Reference
	\vspace{-0.7em}
}
%\author{ Timon Knigge, Ragnar Groot Koerkamp, \& Harry Smit }
\author{
	\Large \textbf{ETH Team}\\
%	Timon Knigge, Ragnar Groot Koerkamp, \& Harry Smit
}
\date{
	\vspace{-0.7em}
	SWERC 2018
	\vspace{-1.9em}
}


%*************** Table of Contents ***************
\usepackage[toc]{multitoc}			% multicolumn toc
\usepackage{tocloft}				% to reduce toc spacing
\renewcommand*{\multicolumntoc}{2}
% reduce section spacing in toc
\setlength{\cftbeforesecskip}{-1pt}
\setlength{\cftbeforesubsecskip}{-1.5pt}
% remove the toc title
\makeatletter
\renewcommand{\@cftmaketoctitle}{}
\makeatother


%*************** Headings ***************
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\setlength{\headsep}{0.4em}
\setlength{\footskip}{0em}

% two sided
%\fancyhead[RE]{\bfseries Curiously Recurring \hspace{6.5em}}
%\fancyhead[LO]{\hspace{5em} Utrecht University}
%\fancyhead[LE,RO]{\thepage}
%\fancyhead[C]{\leftmark}

% one sided
\fancyhead[L]{\hspace{5em} ETH Z\"urich \phantom{-} \bfseries
ETH Team}
\fancyhead[R]{\thepage \hspace{0.5em}}
\fancyhead[C]{\leftmark}

%*************** Code highlighting ***************
\lstset{
	backgroundcolor=\color{white},
	tabsize=4,
	language=C++,
	basicstyle=\footnotesize\ttfamily,
	frame=lines,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
	keywordstyle=\color[rgb]{0, 0, 1},
	commentstyle=\color[rgb]{0, 0.5, 0},
	stringstyle=\color{red}
}


%*************** Section entries ***************
% \entry{name}{description}{snippet location}{complexity}{dependencies}
\newcommand{\entry}[3]{
	\subsection{#1}
	#2
	\ifthenelse{\equal{#3}{}}{}{\lstinputlisting[firstline=2]{#3}}
}
\newcommand{\otherentry}[3]{
	\subsection{#1}
	#2
	\lstinputlisting[language=]{#3}
}


%*************** Begin document ***************
\begin{document}


%*************** Reduce align spacing ***************
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{0pt}
\setlength{\abovedisplayshortskip}{0pt}
\setlength{\belowdisplayshortskip}{0pt}

%*************** Titlepage ***************
{\let\newpage\relax\maketitle}
\tableofcontents
\thispagestyle{empty}
\newpage

%*************** Contents ***************

\section{Datastructures}

\entry{Union Find}
{}
{./snippets/datastructures/unionfind.cpp}

\entry{Fenwick Tree}
{Can be generalized to arbitrary dimensions by duplicating loops.}
{./snippets/datastructures/fenwick.cpp}

\entry{Skew Heap}
{Meldable heap, all operations in $O(\log n)$ time.}
{./snippets/datastructures/skew-heap.cpp}

\entry{Segment Tree}{Works bottom up, so not suitable for lazy propagation.}
{./snippets/datastructures/segmenttree.cpp}

\entry{Lazy Dynamic Segment Tree}
{Here \texttt{T} is the data type and \texttt{U} the lazy update type.
Implement all helper functions.}
{./snippets/datastructures/segmenttree_dynamic.cpp}

\entry{Heavy-Light decomposition}{}
{./snippets/datastructures/heavylight.cpp}


\entry{Sequence}{This is essentially a treap, but it needs special
	functionality for the Euler Tour Tree}
{./snippets/datastructures/sequence.cpp}

\entry{Euler Tour Tree}{Maintain information about the trees using
	the underlying \texttt{seq} datastructure.}
{./snippets/datastructures/euler-tour-tree.cpp}

\entry{Suffix Array}{An $O(n \log n)$ implementation. Note that the resulting
	array maps values to their position in the suffix array, so invert if
	necessary.}
{./snippets/datastructures/suffixarray.cpp}

\entry{Convex Hull Set}{}{./snippets/datastructures/convex-hull-set.cpp}

\entry{GNU Built-in datastructures}
{These require \texttt{gnu} so check in test session.}
{./snippets/datastructures/builtin.cpp}

\section{Combinatorics}

\subsection{Formulae}
\subsubsection*{Permutations}
The number of derangements $D_n$, $n$-permutations without a fixed point,
satisfies $D_{n+1} = n(D_n + D_{n-1}) = (n+1)D_n + (-1)^{n+1}$. If
$g_S(n)$ counts the number of $n$-permutations whose cycle lengths are in
$S$, then
		$$\sum_{n=0}^\infty g_S(n)\frac{x^n}{n!} = \exp\Big(\sum_{k\in S}
			\frac{x^k}{k}\Big)$$

Stirling numbers of the first kind $S_1(n, k)$ count permutations on $n$ items
with $k$ cycles. $S_1(n, k) = S_1(n-1, k-1) + (n-1)S_1(n-1, k)$ with
$S_1(0, 0) = 1$. Note $\sum_{k=0}^n S_1(n, k)x^k = x(x+1)\dots(x+n-1)$.

Eulerian numbers $E(n, k)$ count the number of permutations on $n$ elments,
with exactly $k$ elements that are greater than their predecessor, i.e.
$k$ `ascents'. We have $E(n, k) = (n-k)E(n-1,k-1)+(k+1)E(n-1,k)$ with
$E(n, 0) = E(n, n-1)=1$.

\subsubsection*{Binomials and other partitionings}
We have $\binom{n}{k} = \binom{n-1}{k}+\binom{n-1}{k-1} =
	\prod_{i=1}^k \frac{n-i+1}{i}$. This last product may be computed
incrementally since any product of $k'$ consecutive values is divisibleby
$k'!$.

Basic identities: The hockeystick identity: $\sum_{k=r}^n \binom{k}{r}
	= \binom{n+1}{r+1}$
or $\sum_{k\leq n}\binom{r+k}{k} = \binom{r+n+1}{n}$.
Also $\sum_{k=0}^n \binom{k}{m} = \binom{n+1}{m+1}$.

For $n, m \geq 0$ and $p$ prime. Write $n, m$ in base $p$, i.e.
$n = n_k p^k + \dots + n_1 p + n_0$ and $m = m_k p^k + \dots m_1 p + m_0$. Then
by Lucas theorem we have $\binom{n}{m} \equiv \prod_{i=0}^k \binom{n_i}{m_i}
	\mod p$, with the convention that $n_i < m_i \implies \binom{n_i}{m_i} =0$.

We can put $n$ indistinguishable items into $k$ distinguishable bins in exactly
$\binom{n+k-1}{k-1}$ ways, or if we require the bins be non-empty, in
$\binom{n-1}{k-1}$ ways.

Stirling numbers of the second kind $S_2(n, k)$ count partitions of $n$
distinct elements into exactly $k$ non-empty groups.
$S_2(n, k) = S_2(n-1, k-1) + kS_2(n-1, k)$ with $S_2(n, 1) = S_2(n, n) = 1$ and
$$S_2(n, k) = \frac{1}{k!}\sum_{i=0}^k (-1)^{k-i}\binom{k}{i}i^n$$

Bell numbers $B_n$ count arbitrary partitions of $n$ distinct elements, i.e.
$B_n = \sum_k S_2(n, k)$.

\subsubsection*{Catalan numbers}
Catalan numbers $C_n$ satisfy $C_n = \frac{1}{2n+1}\binom{2n}{n}$ as well
as $C_0 = 1, C_{n+1} = \sum_i C_i C_{n-i}$. These count, among other things:
\begin{itemize}
	\item Valid parenthesis sequences of length $2n$.
	\item Sub-diagonal monotone paths from $(0, 0)$ to $(n, n)$ in the
		$n\times n$ grid.
	\item Complete binary trees (i.e. no vertices with exactly $1$ child)
		with $n+1$ leaves.
	\item Triangulations of a convex polygon with $n+2$ sides.
	\item Stack-sortable permutations of size $n$.
\end{itemize}

\subsubsection*{Trees}
There are $n^{n-2}$ labeled unrooted (cq. $n^{n-1}$ rooted) trees on $n$
vertices. A bijection between a tree and it's Pr\"ufer sequence
$(a_1, a_2, \dots, a_{n-2})$is given by:
\begin{enumerate}
	\item[$\leftarrow$] Given the Pr\"ufer sequence, let $d_i$ be $1$ plus the
		number of occurences of $i$ in $a$. Now for each $a_j$ for $j=1\dots$,
		find the lowest
		numbered node $k$ with degree $1$ and add $\{a_j, k\}$, and decrement
		the degrees $d_{a_j}, d_k$. At the end two degree $1$ nodes remain,
		connect them.
	\item[$\rightarrow$] Iterate, at step $i=1\dots$ pick the leaf with the
		smallest label and set the $i^{th}$ element of $a$ to be its
		neighbour.
\end{enumerate}

\subsection{Burnside's lemma}
Given a group $G$ acting on a set $X$, the number of elements in $X$ up to
symmetry is $$\frac{1}{|G|}\sum_{g\in G} |X^g|$$ with $X^g$ the elements of
$X$ invariant under $g$. For example, if $f(n)$ counts ``configurations''
of some sort of length $n$, and we want to count them up to rotational symmetry
using $G = \mathbb{Z}/n\mathbb{Z}$, then

$$g(n) = \frac{1}{n} \sum_{k=0}^{n-1} f(\gcd(n, k))
	= \frac{1}{n}\sum_{k \| n} f(k) \phi(n / k)$$

I.e. for coloring with $c$ colors we have $f(k) = k^c$.

Relatedly, in P\'olya's enumeration theorem we imagine $X$ as a set of $n$
beads with $G$ permuting the beads (e.g. a necklace, with $G$ all rotations and
reflections of the $n$-cycle, i.e. the dihedral group $D_n$).
Suppose further that we had $Y$ colors, then
the number of $G$-invariant colorings $Y^X / G$ is counted by

$$\frac{1}{|G|}\sum_{g\in G} |Y|^{c(g)}$$

with $c(g)$ counting the number of cycles of $g$ when viewed as a permutation
of $X$. We can generalize this to a weighted version: if the color $i$ can
occur exactly $r_i$ times, then this is counted by the coefficient of
$t_1^{r_1}\dots t_n^{r_n}$ in the polynomial
$$Z(t_1,\dots,t_n) = \frac{1}{|G|}\sum_{g\in G} \prod_{m\geq 1}
	(t_1^m+\dots+t_n^m)^{c_m(g)}$$
where $c_m(g)$ counts the number of length $m$ cycles in $g$ acting as a
permutation on $X$. Note we get the original formula by setting all $t_i=1$.
Here $Z$ is the cycle index. Note: you can cleverly deal with even/odd sizes
by setting some $t_i$ to $-1$.


\subsection{Inclusion-Exclusion}

For appropriate $f$ compute $\sum_{S\subseteq T} (-1)^{|T\setminus S|} f(S)$,
or if only the size of $S$ matters, $\sum_{s=0}^n (-1)^{n-s} \binom{n}{s}f(s)$.
In some contexts we might use Stirling numbers, not binomial coefficients!

Some useful applications:
\begin{enumerate}
	\item[] \textbf{Graph coloring} Let $I(S)$ count the number
		of independent sets
		contained in $S \subseteq V$ ($I(\emptyset) = 1$,
		$I(S) = I(S\setminus v) + I(S\setminus N(v))$). Let
		$c_k = \sum_{S\subseteq V} (-1)^{|V\setminus S|} I(S)$. Then $V$
		is $k$-colorable iff $v > 0$. Thus we can compute the chromatic
		number of a graph in $O^*(2^n)$ time.
\end{enumerate}

\entry{Subset enumeration}
{Note: for sum over subsets use FSC.}
{./snippets/utils/bitmasking.cpp}

\entry{Fast Subset Convolution}
{Sets $a'(S) = \sum_{T\subseteq S} a(T)$ in $O(n2^n)$ time (rather than
$O(3^n)$ or even $O(4^n)$).}
{./snippets/combinatorics/fsc.cpp}

\subsection{Stable Marriage Algorithm}
Given $n$ men and $n$ women, with each man ranking each woman by preference
(and vice versa) (i.e. these are permutations),
we can find a stable marriage by applying the following
procedure:
\begin{itemize}
	\item Initialize all men $m$ and women $w$ to `free'.
	\item While there is a free man $m$ for whom there is some woman $w$ he
		has not proposed to, let $w$ be the first/most prefered such woman. Now
		$m$ proposes to $w$.
	\begin{itemize}
		\item If $w$ is free, then $(m, w)$ become engaged.
		\item If $w$ is engaged to $m'$ and $w$ prefers $m'$, nothing happens.
		\item If $w$ is engaged to $m'$ and $w$ prefers $m$, then $(m, w)$
			become engaged and $m'$ becomes free.
	\end{itemize}
\end{itemize}
With the right bookkeeping this can be done in $O(n^2)$ time. It is guaranteed
the resulting configuration marries everyone, and there are no unstable
marriages (a man and a woman not engaged to each other, but both prefer each
other over their actual partner). When the number of men and women is different
we can add dummy people that noone prefers.

\entry{Bron-Kerbosch}
{Maximal clique enumeration, runs in about $O(3^{n/3})$ time (or
	$O(\#cliques)$).}
{./snippets/graphs/bronkerbosch.cpp}

\entry{$2$-SAT}{}
{./snippets/combinatorics/2-sat.cpp}

\entry{Simplex Algorithm}
{Maximize $c^tx$ subject to $Ax\leq b$ and $x\geq 0$. With
$A[m\times n], b[m], c[n], x[n]$. Solution in $x$.}
{./snippets/combinatorics/simplex.cpp}

\section{Graph Algorithms}

\entry{Tarjan's Algorithm}{}
{./snippets/graphs/tarjan.cpp}

\entry{Biconnected Components}{}
{./snippets/graphs/biconnected_component.cpp}

\entry{Eulerian paths and tours}
{In an \textit{undirected graph}, an \textit{Eulerian Circuit} exists if and
only if all vertices have even degree, and all vertices of nonzero degree
belong to a single connected component. In an \textit{undirected graph},
an \textit{Eulerian Trail} exists if and only if at most two vertices have
odd degree, and all of its vertices of nonzero degree belong to a single
connected component. In a \textit{directed graph}, an \textit{Eulerian Circuit}
exists if and only if every vertex has equal indegree and outdegree, and all
vertices of nonzero degree belong to a single strongly connected component.
In a \textit{directed graph}, an \textit{Eulerian Trail} exists if and only
at most one vertex has $outdegree - indegree = 1$, at most one vertex has
$indegree - outdegree = 1$, every other vertex has equal indegree and
outdegree, and all vertices of nonzero degree belong to a single strongly
connected component \textit{in the underlying undirected graph}.}
{./snippets/graphs/euleriancircuits.cpp}

\entry{Bellmann-Ford}{$O(VE)$}{./snippets/graphs/bellmannford.cpp}

\subsection{Johnson's reweighting}
For computing all pairs shortest paths in sparse graphs with negative weights.
Apply Bellman-Ford to the graph with \texttt{d[u] = 0} (as if an extra
vertex with zero weight edges were added), then reweight edges to
$w_{uv} + h_u - h_v$, then use Dijkstra from every vertex.
The result is $O(VE + (V+E)(\log E))$.

\subsection{Tree isomorphisms}
For a rooted tree isomorphism, from the lowest level to the highest, compute
a hash for each subtree based on the ordered or unordered set of hashes of
the children. This can be implemented deterministically and fast using radix
sorts, but this takes a lot of code - use strong hash functions instead.

For an unrooted tree isomorphism, try finding a rooted tree isomorphism between
all pairs of centroids.

\subsection{Relevant Theorems}
\begin{description}
\item[Kirchhoff's Theorem]
Given an undirected graph $G$ on $n$ vertices, let $D$ be the $n\times n$
matrix with all degrees on the diagonal, and $A$ the $n\times n$ incidence
matrix of $G$. Let $M$ be any minor (remove one row and one column) of $D-A$.
Then the number of spanning trees of $G$ is $|\det M|$.
\item[Acyclicity]
A directed graph is acyclic if and only a depth-first search yields no back
edges.
\end{description}

\section{Flows and cuts}
\subsection{Relevant theorems}
\begin{description}
	\item[Min-Cut Max-Flow] The minimum cut separating $s$ and $t$ equals the
		maximum flow between $s$ and $t$.
	\item[K\"onigs Theorem] There is a bijection between the maximum matchings
		in a bipartite graph and the minimal vertex covers. To find the cover:
		find a maximum matching and run minimum cut inference. Then pick all
		vertices that are on the `wrong' side. Also note the complement of a
		minimum vertex cover is a maximum independent set.
	\item[Hall's Marriage Theorem] For a bipartite graph $(L \cup R, E)$, a
		matching saturating $L$ exists iff $\forall L' \subseteq L$ we have
		$|L'| \leq |N(L')|$ where $N(L')$ is the neighbour set of $L'$.
	\item[Dilworth's Theorem] The minimum number of disjoint chains into which
		a partial ordering $S$ can be decomposed equals the length of
		the longest antichain of
		$S$. Compute by defining a bipartite graph with $l_x$ and $r_x$ for
		each $x \in S$, and add $(l_x, r_y)$ if $l_x \leq r_y, y \neq x$. For
		a maximum matching of size $m$ the number of disjoint chains is then
		$|S|-m$. To find the actual antichain, find the minimal vertex cover
		and take all $x$ with neither $l_x$ nor $r_x$ in the cover.
		
		As for the decomposition into chains,
		note that actually, $S$ does not have to be a partial order, but can be
		any DAG. Then we find a decomposition of the DAG into disjoint paths.
	\item[Mirsky's Theorem] Dual theorem to the above, for the smallest
		decomposition into antichains and the longest chain. Easily computable
		using dynamic programming.
\end{description}

\entry{Flow Graph}
{Datastructure used by all flow algorithms}
{./snippets/flowalgorithms/flowgraph.cpp}

\entry{Dinic Algorithm}
{Runs in $O(V^2 E)$, or $O(VE \log U)$ after introducing scaling.}
{./snippets/flowalgorithms/dinic.cpp}

\entry{Minimum Cut Inference}{}
{./snippets/flowalgorithms/infermincut.cpp}

\entry{Minimum Cost Flow}
{Cannot handle negative cycles}
{./snippets/flowalgorithms/mincostflow.cpp}

\subsection{Cirulations}
Add a supersource S and supersink T. For an arc $(x, y)$ with lowerbound $l$
and upperbound $u$, set its new capacity to $u-l$, and add arcs $(S, y)$ and
$(x, T)$ with capacity $l$. Then find a flow from $S$ to $T$. This corresponds
to a circulation if the flow equals $\sum_{(x, y)} l$.

Note: This approach can often be speed up significantly by merging double
edges.

\section{Dynamic Programming}

\subsection{Distinct subsequences}
For a sequence $a_1, \dots, a_n$, the number of distinct subsequences $s_i$
is found with $s_0 = 1$ and $s_i = 2 s_{i-1} - s_j$ where $j$ is the previous
occurrence of $a_i$.

\entry{LIS}
{For the actual sequence, store parent pointers. Note that longest common
subsequence can be reduced to LIS with unique elements.}
{./snippets/dp/lis.cpp}

\entry{All Nearest Smaller Values}{}{./snippets/dp/ansv.cpp}

\subsection{DP Optimalizations}
\begin{enumerate}
	\item[CH] Recurrences are generally of the form
		$dp_i = dp_j \cdot a_i + b_j$ or equivalent. Insert all lines as
		functions of $a_i$ into the convex hull set (see datastructures) to
		query in logarithmic time.
	\item[DC] Recurrences are generally of the form
		$dp_{k,i} = \max_{j<i} f(dp_{k-1,j}, i, j, k)$. If the $\arg\max$ is
		monotonic in $i$, do divide and conquer by first finding the answer
		for $i = \frac{n}{2}$, and then recursing for larger and smaller $i$.
	\item[Knuth] Recurrences are generally of form similar to
		$$dp_{i,j} = min_{i\leq k<j} \big(f(i, j) + dp_{i,k} + dp_{k+1,j}\big)$$
		Let $a_{i,j}$ be the $\text{argmin}$ for $dp_{i, j}$, then if
		$a_{i,j-1} \leq a_{i, j} \leq a_{i+1,j}$, for a fixed $len > 0$ the
		ranges we have to scan for all $dp_{i, i+len}$ are (almost) disjoint,
		and we can solve the recurrence in $O(n^2)$ time.

		A sufficient condition for applicability on $f$ is, for
		$i\leq j\leq k\leq l$, monotonicity: $f(j,k) \leq f(i, l)$, and
		the quadrangle inequality: $f(i,k)+f(j,l)\leq f(i,l)+f(j,k)$.
\end{enumerate}

\section{Geometry}
\textbf{\color{red} Use 64-bit integer arithmetic whenever possible.}

\subsection{Formulae I}
To \textbf{intersect two lines}, assume by equations of the form
$ax + by = e$. For a line going through points $(x_1, y_1)$ and
$(x_2, y_2)$, note that $\vec{n} = (y_1 - y_2, x_2 - x_1)$ is a normal vector,
so the line equation is given by $\vec{n}\cdot\vec{p}
	 = \vec{n} \cdot (x_1, y_1)$ for
$\vec{p} \in \mathbb{R}^2$. Note: normalizing $\vec{n}$ might be necessary due
to input sizes, but this does result in a loss of precision. Then:
$$\begin{aligned}ax+by=e\\cx+dy=f\end{aligned}
\,\to\,
\begin{aligned}x=\dfrac{ed-bf}{ad-bc}\\y=\dfrac{af-ec}{ad-bc}\end{aligned}$$

This equation is undefined precisely when $ad-bc = 0$, i.e. the given lines
coincide ($e=f$) or are parellel ($e \neq f$). For segment-segment
intersections, just check that $(x, y)$ is in the bounding box of the two
segments.
For a general equation of the form $Ax = b$, we have $x_i = \det A_i / \det A$
with $A_i$ equal to $A$ with the $i^{th}$ column replaced by $b$.

When only deciding whether two segments intersect, there is no need
to compute the intersection point, use determinants instead (or rather,
the derived \texttt{ccw} function). Specifically, the sequence $\vec{a}
	\to \vec{b} \to \vec{c}$ goes counterclockwise iff
$(\vec{b}-\vec{a})\times(\vec{c}-\vec{a})$ is positive, and clockwise if it
is negative. Colinearity if and only if the determinant is $0$.

In \texttt{C++}, the angle between $(x_1, y_1)$ and $(x_2, y_2)$ is
\texttt{atan2(y1-y2, x1-x2)}. Note that it returns values in
$(-\pi, \pi]$. In general though, when sorting by angle, try to use
determinants to avoid precision errors.

The \textbf{projection} of $\vec{u}$ onto $\vec{v}$ is
$\lambda\vec{v}$ for $\lambda = \frac{\vec{u}\cdot\vec{v}}{|\vec{v}|^2}$.
When projecting on a segment, truncate $\lambda$ to $[0, 1]$.

The \textbf{reflection} of $\vec{q}$ through the line $\vec{p_1}\to\vec{p_2}$
is $2\vec{q'} - \vec{q}$ where $\vec{q'}$ is the projection of $\vec{q}$ onto
the line (see above).

To do a \textbf{line-circle intersection} project the center of the circle onto
the line, and move left/right over the line using Pythagoras theorem.

The line intersecting two three-dimensional planes can be found by taking the
cross product of their normal vectors. The three dimensional cross product is
given as:
$$\begin{aligned}
	\begin{bmatrix}
		x_1 \\ y_1 \\ z_1
	\end{bmatrix}
	&\times
	\begin{bmatrix}
		x_2 \\ y_2 \\ z_2
	\end{bmatrix}
	=
	\begin{bmatrix}
		y_1 z_2 - y_2 z_1 \\
		z_1 x_2 - z_2 x_1 \\
		x_1 y_2 - x_2 y_1
	\end{bmatrix}
\end{aligned}$$
Given $\vec{p}, \vec{q}, \vec{r} \in \mathbb{R}^3$, the associated plane
is defined by $\vec{x} \cdot \vec{n} = \vec{p}\cdot\vec{n}$ for
$\vec{n} =(\vec{p}-\vec{r})\times(\vec{q}-\vec{r})$.

\entry{2D Geometry Utilities}{}{snippets/geometry/essentials.cpp}

\subsection{Formulae II}
\begin{equation*}
	[ABC]
	= rs
	= \frac 12 ab\sin\gamma
	= \frac{abc}{4R}
	= \sqrt{s(s-a)(s-b)(s-c)}
	= \frac 12\left| (B-A, C-A)^T \right|
\end{equation*}

\begin{align*}
	s &= \frac {a+b+c}2 & 2R &=\frac{a}{\sin \alpha}\\
	\textrm{cosine rule:}&&  c^2 &= a^2 + b^2 - 2ab\cos \gamma\\
	\textrm{Euler:}&&  1 + CC &= V - E + F\\
	\textrm{Pick:}&& \textrm{Area} &= \textrm{interior points}
	+ \frac{\textrm{boundary points}}2 - 1\\
	p\cdot q &= |p||q|\cos(\theta) & |p\times q| &= |p||q|\sin(\theta)\\
\end{align*}

Given a non-self-intersecting closed polygon on $n$ vertices, given as $(x_i, y_i)$, its centroid $(C_x, C_y)$ is given as:

\begin{align*}
	C_x &= \frac{1}{6A} \sum_{i = 0}^{n - 1} (x_i + x_{i+1}) (x_i y_{i+1} - x_{i+1} y_i), &
	C_y &= \frac{1}{6A} \sum_{i = 0}^{n - 1} (y_i + y_{i+1}) (x_i y_{i+1} - x_{i+1} y_i)
\end{align*}

\begin{equation*}
	A = \frac{1}{2} \sum_{i = 0}^{n - 1} (x_i y_{i+1} - x_{i+1} y_i) = \textrm{polygon area}
\end{equation*}


\entry{Convex Hull}{}
{snippets/geometry/convexhull.cpp}

\subsection{Halfspace intersection}
Intersection is hard, but testing if the intersection is not empty is easy.
Divide the halfplanes into a lower and upper envelope, and build associated
convex hull datastructures $U$ and $L$
(the datastructures contains an online version, though this is not
strictly necessary). Now the function $x \mapsto U(x) - L(x)$ is concave, so
we can ternary search for a maximum, which is positive if and only if the
halfplanes have a non-empty intersection.

\section{Strings}
\entry{Z-Algorithm}{}{snippets/strings/zalgorithm.cpp}
\entry{KMP}{}{snippets/strings/knuthmorrispratt.cpp}
\entry{Aho-Corasick}{}{snippets/strings/ahocorasick.cpp}

\section{Nondeterminism}
\subsection{Hashing}
Possibly \texttt{rand()} draws from a small range, verify by checking
\texttt{RAND\_MAX}. Otherwise use mt19937 (see language documentation).

For a proper rolling hash over a string, fix the modulus, and draw the base
$b$ uniformly at random from $\{0, 1, \dots, p-1\}$. Note that when comparing
rolling hashes of strings of different lengths, it is useful to hash the
empty character to $0$, and hash all actual characters to nonzero values.

Some primes:
\begin{align*}
		10^3 + \{-9,-3,9,13\},
		\quad 10^6 + \{-17, 3, 33\},
		\quad 10^9 + \{7,9,21,33,87\}
\end{align*}

\entry{Timing}{}{snippets/utils/chrono.cpp}

\end{document}
